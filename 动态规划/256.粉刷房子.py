"""
有一排n栋房子，每栋房子都可以涂成三种颜色之一：红色、蓝色或绿色。将每栋房子涂成某种颜色的成本是不同的。您必须粉刷所有房屋，确保没有两个相邻房屋具有相同的颜色。
用某种颜色粉刷每栋房屋的成本由 n x 3 成本矩阵表示。例如，cost[0][0]是将0号房子涂成红色的成本； cost[1][2] 是将房屋 1 涂成绿色的成本，依此类推...求粉刷所有房屋的最小成本。
注意：
所有成本均为正整数。
示例：
输入：[[17,2,17],[16,16,5],[14,3,19]]
输出：10
解释：将房子 0 涂成蓝色，油漆将房子 1 涂成绿色，将房子 2 涂成蓝色。
最低成本：2 + 5 + 3 = 10。

shuru = [[17, 2, 17], [16, 16, 5], [14, 3, 19]]
"""


# 状态转移方程：f(n, i) = min(f(n-1, !i的两种颜色)) + cost(n, i)
def pintHose(costs):
    n = len(costs)
    # 滚动数组  两种状态  来回切换 并且设置边界条件

    # 定义dp
    dp = [[0, 0, 0], [0, 0, 0]]
    # 边界条件
    dp[0] = [costs[0], costs[1], costs[2]]
    # 真实索引从0开始
    for i in range(1, n):
        ind = i % 2
        pre_ind = not ind  # 取反可以跳转到先前状态的索引
        dp[ind][0] = min(dp[pre_ind][1], dp[pre_ind][2]) + costs[i][0]
        dp[ind][1] = min(dp[pre_ind][0], dp[pre_ind][2]) + costs[i][1]
        dp[ind][2] = min(dp[pre_ind][1], dp[pre_ind][0]) + costs[i][2]
    ind = (n - 1) % 2  # 最后一个房子的花费在哪种状态中

    return min(dp[ind])
