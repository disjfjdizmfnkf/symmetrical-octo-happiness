[TOC]

### 总结基本模式

#### **1.滑动窗口**

滑动窗口模式（Sliding Window pattern）用于对给定数组或链表的特定窗口大小执行所需的操作，例如找到包含所有1的最长子数组。滑动窗口从第一个元素开始，并通过不断向右移动一个元素来调整窗口的长度，根据你解决的具体问题来进行调整具体大小。在某些情况下，窗口大小保持不变，而在其他情况下，窗口的大小会增长或缩小。

<img src="https://hackernoon.imgix.net/images/G9YRlqC9joZNTWsi1ul7tRkO6tv1-8i6d3wi0.jpg?w=1200&q=75&auto=format" alt="image" style="zoom:50%;">

**您可以通过以下一些方法来确定给定的题目可能需要滑动窗口：**

- 问题输入是线性数据结构，例如链表、数组或字符串
- 要求您查找最长/最短的子字符串、子数组或所需值

使用滑动窗口模式的常见问题：

- 大小为“K”的最大子数组和（简单）
- 具有“K”个不同字符的最长子字符串（中）
- 字符串字谜（难）------通过重新排列另一个字母而形成的单词、短语或名称，例如由iceman组成的cinema。

#### **2.双指针或迭代器**

双指针是一种模式，其中两个指针串联遍历数据结构，直到一个或两个指针满足特定条件。在排序数组或链表中搜索对时，双指针通常很有用；例如，当您必须将数组的每个元素与其其他元素进行比较时。

需要两个指针，因为仅使用指针，您就必须不断循环遍历数组才能找到答案。这种使用单个迭代器的来回对于时间和空间复杂度来说是低效的——这个概念被称为渐近分析。虽然使用 1 个指针的强力或简单解决方案可以工作，但它会产生类似于 O(n²) 的结果。在许多情况下，双指针可以帮助您找到具有更好空间或运行时复杂性的解决方案。

<img src="https://hackernoon.imgix.net/images/G9YRlqC9joZNTWsi1ul7tRkO6tv1-x4da3w5y.jpg?w=1200&q=75&auto=format" alt="image" style="zoom:42%;" />



确定何时使用两指针方法的方法：

- 它将解决处理排序数组（或链接列表）并需要找到满足某些约束的一组元素的问题
- 数组中的元素集是一对、三元组，甚至是子数组

以下是一些具有两指针模式特征的问题：

- 对排序数组进行平方（简单）
- 总和为零的三元组（中）
- 比较包含退格键的字符串（中）

#### **3.快慢指针** 

快慢指针方法，也称为兔龟算法，是一种指针算法，它使用两个以不同速度在数组（或序列/链表）中移动的指针。**这种方法在处理循环链表或数组时非常有用。**

通过以不同的速度移动（例如，在循环链表中），该算法证明两个指针必然会相遇。一旦两个指针都处于循环中，快指针应该捕获慢指针。

<img src="https://hackernoon.imgix.net/images/G9YRlqC9joZNTWsi1ul7tRkO6tv1-suft3wtu.jpg?w=1200&q=75&auto=format" alt="image" style="zoom:45%;" />

如何确定何时使用快模式和慢模式？

- 问题将处理链表或数组中的循环
- 当需要知道某个元素的位置或者链表的总长度时。

我什么时候应该使用它而不是上面提到的两指针方法？

- 在某些情况下，您不应该使用两指针方法，例如在无法向后移动的单链表中。何时使用快速和慢速模式的一个示例是当您尝试确定链接列表是否是回文时。

快慢指针模式的问题：

- 链表循环（简单）

- 回文链表（中）

- 圆形数组中的循环（难）

  


#### **4.合并区间**

合并间隔模式是处理重叠间隔的有效技术。在许多涉及区间的问题中，您要么需要找到重叠的区间，要么需要合并重叠的区间。该模式的工作原理如下：

给定两个音程（“a”和“b”），这两个音程可以通过六种不同的方式相互关联：

<img src="https://hackernoon.imgix.net/images/G9YRlqC9joZNTWsi1ul7tRkO6tv1-8mh13wm9.jpg?w=1200&q=75&auto=format" alt="image" style="zoom:50%;" />

理解和认识这六种情况将帮助您解决从插入间隔到优化间隔合并的各种问题。

如何确定何时使用合并间隔模式？

- 如果要求您生成一个仅包含互斥间隔的列表

- 如果您听到术语“重叠间隔”。

  合并区间问题模式：

- 间隔交点（中）

- 最大 CPU 负载（硬）

#### **5.循环排序**

该模式描述了一种有趣的方法来处理涉及包含给定范围内的数字的数组的问题。循环排序模式一次迭代一个数字，如果您正在迭代的当前数字不在正确的索引处，则将其与正确索引处的数字交换。您可以尝试将数字放入正确的索引中，但这会产生 O(n^2) 的复杂度，这不是最佳的，因此出现了循环排序模式。

<img src="https://hackernoon.imgix.net/images/G9YRlqC9joZNTWsi1ul7tRkO6tv1-t8i13wdp.jpg?w=1200&q=75&auto=format" alt="image" style="zoom:50%;" />



我如何识别这种模式？

- 它们将是涉及给定范围内的数字的排序数组的问题
- 如果问题要求您在排序/旋转数组中找到丢失/重复/最小的数字

循环排序模式的问题：

- 找到丢失的号码（简单）
- 找到最小的缺失正数（中）

#### **6.链表的就地反转**

在很多问题中，您可能会被要求反转链表的一组节点之间的链接。通常，限制是您需要就地执行此操作，即使用现有的节点对象并且不使用额外的内存。这就是上面提到的模式有用的地方。

此模式一次反转一个节点，从一个变量（当前）指向链表的头部开始，一个变量（前一个）将指向您已处理的前一个节点。以锁步方式，您将通过将当前节点指向前一个节点来反转当前节点，然后再移动到下一个节点。此外，您将更新变量“previous”以始终指向您已处理的上一个节点。

<img src="https://hackernoon.imgix.net/images/G9YRlqC9joZNTWsi1ul7tRkO6tv1-gekl3wfd.jpg?w=1200&q=75&auto=format" alt="image" style="zoom:50%;" />

如何确定何时使用此模式：

- 如果要求您在不使用额外内存的情况下反转链表

链表模式就地反转的问题：

- 反转子列表（中）
- 反转每个 K 元素子列表（中）

#### **7.树BFS**

此模式基于广度优先搜索 (BFS) 技术来遍历树，并在跳到下一个级别之前使用队列来跟踪级别的所有节点。使用这种方法可以有效地解决涉及逐级遍历树的任何问题。

Tree BFS 模式的工作原理是将根节点推入队列，然后不断迭代，直到队列为空。对于每次迭代，我们删除队列头部的节点并“访问”该节点。从队列中删除每个节点后，我们还将其所有子节点插入队列中。

如何识别Tree BFS模式：

- 如果要求您以逐级方式遍历树（或级别顺序遍历）

Tree BFS 模式的问题：

二叉树层次顺序遍历（简单）

- 之字形遍历（中）

#### **8. Tree DFS**

树 DFS 基于深度优先搜索 (DFS) 技术来遍历树。

您可以使用递归（或迭代方法的堆栈）来在遍历时跟踪所有先前（父）节点。

树 DFS 模式的工作原理是从树的根开始，如果节点不是叶子，则需要执行三件事：

1. 决定是立即处理当前节点（前序），还是在处理两个子节点之间（按顺序）或在处理两个子节点之后（后序）。
2. 对当前节点的两个子节点进行两次递归调用来处理它们。

如何识别Tree DFS模式：

- 如果要求您使用中序、前序或后序 DFS 遍历树
- 如果问题需要搜索节点更接近叶子的东西

Tree DFS 模式的问题：

- 路径号总和（中）
- 所有路径求和（中）

#### **9. Two heaps**

在许多问题中，我们都会得到一组元素，以便我们可以将它们分为两部分。为了解决这个问题，我们有兴趣知道一个部分中的最小元素和另一部分中的最大元素。该模式是解决此类问题的有效方法。

该模式使用两个堆；最小堆用于查找最小元素，最大堆用于查找最大元素。该模式的工作原理是将前半部分数字存储在最大堆中，这是因为您想找到前半部分中最大的数字。然后，您将数字的后半部分存储在最小堆中，因为您想找到后半部分中最小的数字。任何时候，都可以从两个堆的顶部元素计算出当前数字列表的中位数。

识别两堆模式的方法：

- 在优先级队列、调度等情况下很有用
- 如果问题表明您需要找到集合中的最小/最大/中值元素
- 有时，对于具有二叉树数据结构的问题很有用

问题特色

- 求数流的中位数（中）

#### **10.子集**

大量的编码面试问题涉及处理给定元素集的排列和组合。子集模式描述了一种有效的广度优先搜索（BFS）方法来处理所有这些问题。

该模式如下所示：

给定一组 [1, 5, 3]

1. 从空集开始：[[]]
2. 将第一个数字 (1) 添加到所有现有子集以创建新子集：[[], [1]]；
3. 将第二个数字（5）添加到所有现有子集：[[], [1], [5], [1,5]]；
4. 将第三个数字 (3) 添加到所有现有子集：[[], [1], [5], [1,5], [3], [1,3], [5,3], [1, 5,3]]。

这是子集模式的直观表示：

<img src="https://hackernoon.imgix.net/images/G9YRlqC9joZNTWsi1ul7tRkO6tv1-hemg3w8d.jpg?w=1200&q=75&auto=format" alt="image" style="zoom:50%;" />

如何识别子集模式：

- 需要找到给定集合的组合或排列的问题
- 子集模式的问题：
- 具有重复项的子集（简单）
- 通过更改大小写进行字符串排列（中）

#### **11.修改后的二分搜索**

每当给你一个排序数组、链表或矩阵，并要求你找到某个元素时，你可以使用的最好的算法就是二分搜索。该模式描述了处理涉及二分搜索的所有问题的有效方法。

对于升序集，模式如下所示：

1. 首先，找到开始和结束的中间位置。找到中间值的一个简单方法是：middle = (start + end) / 2。但这很可能会产生整数溢出，因此建议您将中间值表示为：middle = start + (end - start) / 2
2. 如果键等于索引 middle 处的数字，则返回 middle
3. 如果“key”不等于索引中间：
4. 检查 key 是否 < arr[middle]。如果将搜索减少到 end = middle — 1
5. 检查 key 是否 > arr[middle]。如果将搜索减少到 end = middle + 1

以下是修改后的二分搜索模式的直观表示：

<img src="https://hackernoon.imgix.net/images/G9YRlqC9joZNTWsi1ul7tRkO6tv1-kxno3wrs.jpg?w=1200&q=75&auto=format" alt="image" style="zoom:50%;" />

修改二分搜索模式的问题：

与顺序无关的二分搜索（简单）在排序的无限数组中搜索（中）

#### **12. 前k个元素**

任何要求我们在给定集合中找到顶部/最小/频繁“K”元素的问题都属于这种模式。

跟踪“K”元素的最佳数据结构是堆。该模式将利用堆来解决一次处理一组给定元素中的“K”个元素的多个问题。该模式如下所示：

1. 根据问题将“K”个元素插入最小堆或最大堆。
2. 遍历剩余的数字，如果发现一个比堆中的数字大，则删除该数字并插入较大的数字。

<img src="https://hackernoon.imgix.net/images/G9YRlqC9joZNTWsi1ul7tRkO6tv1-uuow3wb1.jpg?w=1200&q=75&auto=format" alt="image" style="zoom:50%;" />

不需要排序算法，因为堆会为您跟踪元素。

如何识别前“K”元素模式：

- 如果要求您查找给定集合中顶部/最小/频繁的“K”元素
- 如果要求您对数组进行排序以找到精确的元素

具有前“K”元素模式的问题：

- 前“K”数字（简单）
- 前“K”个频繁数字（中）

#### **13. K-way Merge （k路合并）**

K-way Merge 可帮助您解决涉及一组排序数组的问题。

每当给定“K”个排序数组时，您都可以使用堆来有效地对所有数组的所有元素执行排序遍历。您可以将每个数组的最小元素推入最小堆中以获得总体最小值。获得总体最小值后，将同一数组中的下一个元素推送到堆中。然后，重复这个过程，对所有元素进行排序遍历。

<img src="https://hackernoon.imgix.net/images/G9YRlqC9joZNTWsi1ul7tRkO6tv1-4hwy3w8x.jpg?w=1200&q=75&auto=format" alt="image" style="zoom:50%;" />

该模式如下所示：

1. 将每个数组的第一个元素插入最小堆中。
2. 之后，从堆中取出最小（顶部）元素并将其添加到合并列表中。
3. 从堆中删除最小元素后，将同一列表的下一个元素插入到堆中。
4. 重复步骤 2 和 3 以按排序顺序填充合并列表。

如何识别 K-way 合并模式：

- 问题将以排序数组、列表或矩阵为特征
- 如果问题要求您合并排序列表，请找到排序列表中的最小元素。

K-way Merge 模式的问题：

- 合并 K 个排序列表（中）
- 总和最大的 K 对（困难）

#### **14. Topological sort（拓扑排序）**

拓扑排序用于查找相互依赖的元素的线性排序。例如，如果事件“B”依赖于事件“A”，则在拓扑排序中“A”位于“B”之前。

该模式定义了一种简单的方法来理解对一组元素执行拓扑排序的技术。

该模式的工作原理如下：

1. 初始化
    a）使用HashMap将图存储在邻接列表中 
   
   b）要查找所有源，请使用HashMap来保留入度数构建图并查找所有顶点的入度
   
2. 从输入构建图表并填充以度为单位的 HashMap。

3. 查找所有源
   
   a) 所有入度为“0”的顶点都将是源并存储在队列中。
   
4. 排序
   a) For each source, do the following things:
   —i) Add it to the sorted list.
   — ii)Get all of its children from the graph.
   — iii)Decrement the in-degree of each child by 1.
   — iv)If a child’s in-degree becomes ‘0’, add it to the sources Queue.
   b) Repeat (a), until the source Queue is empty.对 进行排序
   
    a) 对于每个源，执行以下操作： 
   
   ​		—i) 将其添加到排序列表中。 
   
   ​		— ii) 从图中获取其所有子项。 
   
   ​		— iii) 递减每个子节点的入度增加 1。 
   
   ​		— iv)如果某个子节点的入度变为“0”，则将其添加到源队列中。 
   
   b) 重复 (a)，直到源队列为空。
   
5. <img src="https://hackernoon.imgix.net/photos/G9YRlqC9joZNTWsi1ul7tRkO6tv1-ve1473wvg?w=1200&q=75&auto=format" alt="image" style="zoom:50%;" />

6. 如何识别拓扑排序模式：

- 该问题将处理没有有向循环的图
- 如果要求您按排序顺序更新所有对象
- 如果您有一类遵循特定顺序的对象

拓扑排序模式的问题：

- 任务调度（中）
- 树的最小高度（难）

#### **15.递归Recursion**

将复杂问题分成小问题解决

* 递归遇到重复计算的情况                  ----->       使用memorization 记忆
* 递归遇到子问题结果组合的情况       ----->      使用divide-and-conquer  分治
* 递归要返回所有满足条件的解答       ----->      使用backtracking 回溯

**接下来是什么？**
